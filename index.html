<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Giao diện Người dùng</title>
  <style>
    body {
      background: #1e1e1e;
      color: #e0e0e0;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    h1, h2 {
      text-align: center;
    }
    .container {
      max-width: 500px;
      margin: 20px auto;
      padding: 10px;
    }
    input, button {
      font-size: 1em;
    }
    /* Form styles */
    .form-group {
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
    }
    .form-group label {
      margin-bottom: 5px;
    }
    .form-group input[type="text"], 
    .form-group input[type="password"], 
    .form-group input[type="email"], 
    .form-group input[type="tel"] {
      padding: 8px;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2b2b2b;
      color: #fff;
    }
    .actions {
      text-align: center;
      margin-top: 20px;
    }
    .actions button {
      background: #424242;
      color: #fff;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 4px;
      cursor: pointer;
    }
    .actions button:hover {
      background: #616161;
    }
    /* Tabs */
    nav {
      text-align: center;
      margin-bottom: 20px;
    }
    nav button {
      background: #333;
      color: #fff;
      border: none;
      padding: 10px 15px;
      margin: 0 5px;
      border-radius: 4px;
      cursor: pointer;
    }
    nav button.active {
      background: #616161;
    }
    /* Sections */
    #main-section {
      display: none;
    }
    #link-section, #totp-section {
      display: none;
    }
    .link-entry {
      margin-bottom: 20px;
      background: #2b2b2b;
      padding: 10px;
      border-radius: 4px;
    }
    .link-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      margin-bottom: 5px;
    }
    .link-actions input {
      flex: 1 1 auto;
      margin-right: 5px;
      padding: 6px;
      border: 1px solid #444;
      border-radius: 4px;
      background: #424242;
      color: #fff;
    }
    .link-actions button {
      padding: 6px 10px;
      margin: 2px;
    }
    .qr-container img {
      max-width: 100%;
      height: auto;
      display: block;
      margin: 5px 0;
    }
    #link-message {
      text-align: center;
      margin-top: 10px;
      font-weight: bold;
      color: #90ee90;
    }
    /* 2FA list */
    #totp-list .totp-item {
      background: #2b2b2b;
      padding: 10px;
      margin-bottom: 15px;
      border-radius: 4px;
    }
    .totp-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    .totp-header .name {
      font-size: 1.1em;
      font-weight: bold;
    }
    .totp-header .code {
      font-size: 1.2em;
      background: #000;
      padding: 4px 8px;
      border-radius: 4px;
      letter-spacing: 2px;
    }
    .totp-actions button {
      padding: 5px 8px;
      margin-left: 5px;
      background: #424242;
    }
    .totp-actions button:hover {
      background: #616161;
    }
    .totp-qr img {
      max-width: 150px;
      height: auto;
      display: block;
      margin-top: 8px;
    }
    /* Responsive adjustments */
    @media (max-width: 500px) {
      .link-actions {
        flex-direction: column;
      }
      .link-actions input {
        margin: 0 0 5px 0;
        width: 100%;
      }
      .link-actions button {
        width: 100%;
      }
      .totp-header {
        flex-direction: column;
        align-items: flex-start;
      }
      .totp-header .code {
        margin-top: 5px;
      }
    }
  </style>
</head>
<body>
  <div class="container" id="login-section">
    <h1>Đăng nhập</h1>
    <div class="form-group">
      <label for="login-user">Email hoặc SĐT:</label>
      <input type="text" id="login-user" />
    </div>
    <div class="form-group">
      <label for="login-pass">Mật khẩu:</label>
      <input type="password" id="login-pass" />
    </div>
    <div class="actions">
      <button id="btn-login">Đăng nhập</button>
      <button id="btn-register">Đăng ký</button>
    </div>
  </div>

  <div class="container" id="register-section" style="display: none;">
    <h1>Đăng ký</h1>
    <div class="form-group">
      <label for="reg-phone">Số điện thoại:</label>
      <input type="tel" id="reg-phone" />
    </div>
    <div class="form-group">
      <label for="reg-email">Email:</label>
      <input type="email" id="reg-email" />
    </div>
    <div class="form-group">
      <label for="reg-pass">Mật khẩu:</label>
      <input type="password" id="reg-pass" />
    </div>
    <div class="actions">
      <button id="btn-do-register">Tạo tài khoản</button>
      <button id="btn-cancel-reg">Hủy</button>
    </div>
  </div>

  <div class="container" id="main-section">
    <h2>Chào <span id="current-user"></span></h2>
    <nav>
      <button id="tab-link" class="active">Đổi mật khẩu</button>
      <button id="tab-totp">2FA</button>
      <button id="btn-logout" style="float:right;">Đăng xuất</button>
    </nav>

    <!-- Change password links section -->
    <div id="link-section">
      <h3>Tạo link đổi mật khẩu</h3>
      <div class="form-group">
        <label for="uid-input">UID người dùng:</label>
        <input type="text" id="uid-input" />
      </div>
      <div class="form-group">
        <label for="code-input">CODE khôi phục:</label>
        <input type="text" id="code-input" />
      </div>
      <div class="form-group" style="flex-direction: row; align-items: center;">
        <input type="checkbox" id="remember-uidcode" style="margin-right:5px;" />
        <label for="remember-uidcode" style="margin:0;">Ghi nhớ UID/CODE</label>
      </div>
      <div class="actions">
        <button id="btn-gen-link">Tạo Link</button>
      </div>
      <!-- Generated links and QRs -->
      <div id="link-results" style="margin-top:20px;"></div>
      <div id="link-message"></div>
    </div>

    <!-- 2FA section -->
    <div id="totp-section" style="display:none;">
      <h3>Quản lý 2FA</h3>
      <div id="totp-form" class="form-group">
        <label for="totp-name">Tên (nhãn):</label>
        <input type="text" id="totp-name" placeholder="Tên dịch vụ" />
      </div>
      <div class="form-group">
        <label for="totp-secret">Khóa bí mật (Base32):</label>
        <input type="text" id="totp-secret" placeholder="Nhập secret" />
      </div>
      <div class="actions">
        <button id="btn-add-totp">Thêm</button>
        <button id="btn-cancel-edit" style="display:none;">Hủy</button>
      </div>
      <div id="totp-list" style="margin-top:20px;"></div>
    </div>
  </div>

  <script>
    /* QRCode.js library (embedded) */
    var qrcode = function() {
      var o = 1, i = 2, a = 4, u = 8;
      var f = { L: 1, M: 0, Q: 3, H: 2 };
      var g = 0, c = 1, h = 2, s = 3, l = 4, v = 5, w = 6, d = 7;
      var y = (t = [
          [], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42],
          [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66],
          [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86],
          [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ], n = function(r) {
          var t = 0;
          while (r !== 0) { t += 1; r >>>= 1; }
          return t;
        }, e = {}
      );
      e.getBCHTypeInfo = function(r) {
        var t = r << 10;
        while (n(t) - n(1335) >= 0) { t ^= 1335 << (n(t) - n(1335)); }
        return 21522 ^ ((r << 10) | t);
      };
      e.getBCHTypeNumber = function(r) {
        var t = r << 12;
        while (n(t) - n(7973) >= 0) { t ^= 7973 << (n(t) - n(7973)); }
        return (r << 12) | t;
      };
      e.getPatternPosition = function(r) { return t[r - 1]; };
      e.getMaskFunction = function(r) {
        switch(r) {
          case g: return function(r, t) { return (r + t) % 2 == 0; };
          case c: return function(r, t) { return r % 2 == 0; };
          case h: return function(r, t) { return t % 3 == 0; };
          case s: return function(r, t) { return (r + t) % 3 == 0; };
          case l: return function(r, t) { return ((Math.floor(r/2) + Math.floor(t/3)) % 2) == 0; };
          case v: return function(r, t) { return (r * t % 2 + r * t % 3) == 0; };
          case w: return function(r, t) { return ((r * t % 2 + r * t % 3) % 2) == 0; };
          case d: return function(r, t) { return ((r * t % 3 + (r + t) % 2) % 2) == 0; };
          default: throw new Error("bad maskPattern:" + r);
        }
      };
      e.getErrorCorrectPolynomial = function(r) {
        var t = B([1], 0);
        for (var i = 0; i < r; i += 1) {
          t = t.multiply(B([1, p.gexp(i)], 0));
        }
        return t;
      };
      e.getLengthInBits = function(r, t) {
        if (1 <= t && t < 10) {
          switch(r) {
            case o: return 10;
            case i: return 9;
            case a:
            case u: return 8;
            default: throw new Error("mode:" + r);
          }
        } else if (t < 27) {
          switch(r) {
            case o: return 12;
            case i: return 11;
            case a: return 16;
            case u: return 10;
            default: throw new Error("mode:" + r);
          }
        } else if (t < 41) {
          switch(r) {
            case o: return 14;
            case i: return 13;
            case a: return 16;
            case u: return 12;
            default: throw new Error("mode:" + r);
          }
        } else {
          throw new Error("type:" + t);
        }
      };
      e.getLostPoint = function(r) {
        var t = r.getModuleCount();
        var e = 0;
        for (var n = 0; n < t; n += 1) {
          for (var o = 0; o < t; o += 1) {
            var a = r.isDark(n, o);
            var u = 0;
            for (var f = -1; f <= 1; f += 1) {
              if (n + f < 0 || t <= n + f) continue;
              for (var g = -1; g <= 1; g += 1) {
                if (o + g < 0 || t <= o + g) continue;
                if (f == 0 && g == 0) continue;
                if (a == r.isDark(n+f, o+g)) u++;
              }
            }
            if (u > 5) {
              e += (3 + u - 5);
            }
          }
        }
        for (var n = 0; n < t - 1; n += 1) {
          for (var o = 0; o < t - 1; o += 1) {
            var g = 0;
            if (r.isDark(n, o)) g++;
            if (r.isDark(n+1, o)) g++;
            if (r.isDark(n, o+1)) g++;
            if (r.isDark(n+1, o+1)) g++;
            if (g == 0 || g == 4) {
              e += 3;
            }
          }
        }
        for (var n = 0; n < t; n += 1) {
          for (var o = 0; o < t - 6; o += 1) {
            if (r.isDark(n, o) && !r.isDark(n, o+1) && r.isDark(n, o+2) && r.isDark(n, o+3) && r.isDark(n, o+4) && !r.isDark(n, o+5) && r.isDark(n, o+6)) {
              e += 40;
            }
          }
        }
        for (var o = 0; o < t; o += 1) {
          for (var n = 0; n < t - 6; n += 1) {
            if (r.isDark(n, o) && !r.isDark(n+1, o) && r.isDark(n+2, o) && r.isDark(n+3, o) && r.isDark(n+4, o) && !r.isDark(n+5, o) && r.isDark(n+6, o)) {
              e += 40;
            }
          }
        }
        var c = 0;
        for (var n = 0; n < t; n += 1) {
          for (var o = 0; o < t; o += 1) {
            if (r.isDark(n, o)) c++;
          }
        }
        var h = Math.abs(c * 100 / t / t - 50) / 5;
        e += h * 10;
        return e;
      };
      function B(r, t) {
        if (r.length === void 0) throw new Error(r.length + "/" + t);
        var e = (function() {
          var e = 0;
          while (e < r.length && r[e] == 0) e += 1;
          var n = new Array(r.length - e + t);
          for (var o = 0; o < r.length - e; o += 1) {
            n[o] = r[o + e];
          }
          return n;
        })();
        var n = {
          getAt: function(r) { return e[r]; },
          getLength: function() { return e.length; },
          multiply: function(r) {
            var t = new Array(n.getLength() + r.getLength() - 1);
            for (var e2 = 0; e2 < n.getLength(); e2 += 1) {
              for (var o = 0; o < r.getLength(); o += 1) {
                t[e2 + o] ^= p.gexp(p.glog(n.getAt(e2)) + p.glog(r.getAt(o)));
              }
            }
            return B(t, 0);
          },
          mod: function(r) {
            if (n.getLength() - r.getLength() < 0) {
              return n;
            }
            var t2 = p.glog(n.getAt(0)) - p.glog(r.getAt(0));
            var e2 = new Array(n.getLength());
            for (var o = 0; o < n.getLength(); o += 1) {
              e2[o] = n.getAt(o);
            }
            for (var o = 0; o < r.getLength(); o += 1) {
              e2[o] ^= p.gexp(p.glog(r.getAt(o)) + t2);
            }
            return B(e2, 0).mod(r);
          }
        };
        return n;
      }
      var A, C;
      var k = (
        A = [
          [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],
          [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],
          [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],
          [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],
          [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],
          [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],
          [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],
          [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],
          [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13],
          [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16],
          [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13],
          [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15],
          [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12],
          [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13],
          [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13],
          [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16],
          [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15],
          [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15],
          [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16],
          [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16],
          [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16],
          [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16],
          [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16],
          [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16],
          [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17],
          [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16],
          [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16],
          [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16],
          [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16],
          [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16],
          [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]
        ], C = {}
      );
      C.getRSBlocks = function(r, t) {
        var e = (function(r, t) {
          switch(t) {
            case f.L: return A[4 * (r - 1) + 0];
            case f.M: return A[4 * (r - 1) + 1];
            case f.Q: return A[4 * (r - 1) + 2];
            case f.H: return A[4 * (r - 1) + 3];
            default: return;
          }
        })(r, t);
        if (e === void 0) throw new Error("bad rs block @ typeNumber:" + r + "/errorCorrectLevel:" + t);
        var i = e.length / 3;
        var a = [];
        for (var u2 = 0; u2 < i; u2 += 1) {
          var g2 = e[3 * u2 + 0];
          var c2 = e[3 * u2 + 1];
          var h2 = e[3 * u2 + 2];
          for (var s2 = 0; s2 < g2; s2 += 1) {
            a.push({ totalCount: c2, dataCount: h2 });
          }
        }
        return a;
      };
      var m = function() {
        var r = [], t2 = 0;
        var e2 = {
          getBuffer: function() { return r; },
          getAt: function(n) {
            var o = Math.floor(n / 8);
            return ((r[o] >>> (7 - n % 8)) & 1) == 1;
          },
          put: function(n, o) {
            for (var i2 = 0; i2 < o; i2 += 1) {
              e2.putBit(((n >>> (o - i2 - 1)) & 1) == 1);
            }
          },
          getLengthInBits: function() { return t2; },
          putBit: function(n) {
            var o = Math.floor(t2 / 8);
            if (r.length <= o) r.push(0);
            if (n) r[o] |= (0x80 >>> (t2 % 8));
            t2 += 1;
          }
        };
        return e2;
      };
      var L = function(text) {
        var mode = a;
        var bytes = qrcode.stringToBytes(text);
        return {
          getMode: function() { return mode; },
          getLength: function() { return bytes.length; },
          write: function(buffer) {
            for (var i2 = 0; i2 < bytes.length; i2 += 1) {
              buffer.put(bytes[i2], 8);
            }
          }
        };
      };
      var D = function() {
        var data = [];
        var obj = {
          writeByte: function(val) { data.push(val & 0xff); },
          writeShort: function(val) { obj.writeByte(val); obj.writeByte(val >>> 8); },
          writeBytes: function(bytes, offset, length) {
            offset = offset || 0;
            length = length || bytes.length;
            for (var i2 = 0; i2 < length; i2 += 1) {
              obj.writeByte(bytes[i2 + offset]);
            }
          },
          writeString: function(s) {
            for (var i2 = 0; i2 < s.length; i2 += 1) {
              obj.writeByte(s.charCodeAt(i2));
            }
          },
          toByteArray: function() { return data; },
          toString: function() {
            var s = "[";
            for (var i2 = 0; i2 < data.length; i2 += 1) {
              if (i2 > 0) s += ",";
              s += data[i2];
            }
            s += "]";
            return s;
          }
        };
        return obj;
      };
      var M = function(base64) {
        var b = base64;
        var length = 0;
        var buffer = 0;
        var bitCount = 0;
        var read = function() {
          while (bitCount < 8) {
            if (length >= b.length) {
              if (bitCount == 0) return -1;
              throw new Error("unexpected end of file./" + bitCount);
            }
            var c2 = b.charAt(length);
            length += 1;
            if (c2 == "=") {
              bitCount = 0;
              return -1;
            }
            if (!c2.match(/^\s$/)) {
              buffer = (buffer << 6) | charCode(c2.charCodeAt(0));
              bitCount += 6;
            }
          }
          var result = (buffer >>> (bitCount - 8)) & 0xff;
          bitCount -= 8;
          return result;
        };
        var charCode = function(c2) {
          if (65 <= c2 && c2 <= 90) return c2 - 65;
          if (97 <= c2 && c2 <= 122) return c2 - 97 + 26;
          if (48 <= c2 && c2 <= 57) return c2 - 48 + 52;
          if (c2 == 43) return 62;
          if (c2 == 47) return 63;
          throw new Error("c:" + c2);
        };
        return { read: read };
      };
      var b = function(width, height) {
        var w2 = width, h2 = height;
        var data = new Array(width * height);
        var obj = {
          setPixel: function(x, y, value) {
            data[y * w2 + x] = value;
          },
          write: function(out) {
            out.writeString("GIF87a");
            out.writeShort(w2);
            out.writeShort(h2);
            out.writeByte(0x80);
            out.writeByte(0);
            out.writeByte(0);
            out.writeByte(0);
            out.writeByte(0);
            out.writeByte(0);
            out.writeByte(0xff);
            out.writeByte(0xff);
            out.writeByte(0xff);
            out.writeString(",");
            out.writeShort(0);
            out.writeShort(0);
            out.writeShort(w2);
            out.writeShort(h2);
            out.writeByte(0);
            var lzwMinCodeSize = 2;
            out.writeByte(lzwMinCodeSize);
            var raster = generateLZW(lzwMinCodeSize);
            out.writeBytes(raster);
            out.writeByte(0);
            out.writeString(";");
          }
        };
        var generateLZW = function(codeSize) {
          var clearCode = 1 << codeSize;
          var endCode = clearCode + 1;
          var bitLength = codeSize + 1;
          var table = tableInit();
          for (var i2 = 0; i2 < clearCode; i2 += 1) {
            table.add(String.fromCharCode(i2));
          }
          table.add(String.fromCharCode(clearCode));
          table.add(String.fromCharCode(endCode));
          var byteOut = D();
          var bitOut = (function(dataOut) {
            var bitBuffer = 0, bitCount = 0;
            return {
              write: function(value, length) {
                if (value >>> length != 0) throw new Error("length over");
                while (bitCount + length >= 8) {
                  dataOut.writeByte(0xff & ((value << bitCount) | bitBuffer));
                  length -= (8 - bitCount);
                  value >>>= (8 - bitCount);
                  bitBuffer = 0;
                  bitCount = 0;
                }
                bitBuffer |= (value << bitCount);
                bitCount += length;
              },
              flush: function() {
                if (bitCount > 0) dataOut.writeByte(bitBuffer);
              }
            };
          })(byteOut);
          bitOut.write(clearCode, bitLength);
          var s = String.fromCharCode(data[0]);
          for (var index = 1; index < data.length; index++) {
            var c2 = String.fromCharCode(data[index]);
            if (table.contains(s + c2)) {
              s = s + c2;
            } else {
              bitOut.write(table.indexOf(s), bitLength);
              if (table.size() < 4095) {
                if (table.size() == (1 << bitLength)) bitLength += 1;
                table.add(s + c2);
              }
              s = c2;
            }
          }
          bitOut.write(table.indexOf(s), bitLength);
          bitOut.write(endCode, bitLength);
          bitOut.flush();
          return byteOut.toByteArray();
        };
        var tableInit = function() {
          var map = {};
          var size = 0;
          return {
            add: function(key) {
              if (this.contains(key)) throw new Error("dup key:" + key);
              map[key] = size;
              size += 1;
            },
            size: function() { return size; },
            indexOf: function(key) { return map[key]; },
            contains: function(key) { return map[key] !== undefined; }
          };
        };
        return obj;
      };
      var S = function(width, height, getPixel, altText) {
        var qrImage = b(width, height);
        for (var y2 = 0; y2 < height; y2 += 1) {
          for (var x = 0; x < width; x += 1) {
            qrImage.setPixel(x, y2, getPixel(x, y2));
          }
        }
        var byteOut = D();
        qrImage.write(byteOut);
        var base64 = (function() {
          var base64Str = "";
          var encodeChar = function(v) {
            base64Str += String.fromCharCode(toCharCode(v & 0x3f));
          };
          var toCharCode = function(n) {
            if (n < 0) {
              // noop
            } else if (n < 26) {
              return 65 + n;
            } else if (n < 52) {
              return 97 + (n - 26);
            } else if (n < 62) {
              return 48 + (n - 52);
            } else if (n == 62) {
              return 43;
            } else if (n == 63) {
              return 47;
            }
            throw new Error("n:" + n);
          };
          var base64Out = {
            writeByte: function(val) {
              bitBuffer = (bitBuffer << 8) | (val & 0xff);
              bitCount += 8;
              byteCount += 1;
              while (bitCount >= 6) {
                encodeChar(bitBuffer >>> (bitCount - 6));
                bitCount -= 6;
              }
            },
            flush: function() {
              if (bitCount > 0) {
                encodeChar(bitBuffer << (6 - bitCount));
                bitBuffer = 0;
                bitCount = 0;
              }
              // padding
              if (byteCount % 3 != 0) {
                var padLen = 3 - (byteCount % 3);
                for (var i2 = 0; i2 < padLen; i2++) {
                  base64Str += "=";
                }
              }
            },
            toString: function() {
              return base64Str;
            }
          };
          var bitBuffer = 0, bitCount = 0, byteCount = 0;
          var dataArr = byteOut.toByteArray();
          for (var i2 = 0; i2 < dataArr.length; i2 += 1) {
            base64Out.writeByte(dataArr[i2]);
          }
          base64Out.flush();
          return base64Out.toString();
        })();
        var imgTag = "";
        imgTag += "<img";
        imgTag += ' src="';
        imgTag += "data:image/gif;base64,";
        imgTag += base64;
        imgTag += '"';
        imgTag += ' width="' + width + '"';
        imgTag += ' height="' + height + '"';
        if (altText) {
          imgTag += ' alt="' + altText + '"';
        }
        imgTag += "/>";
        return imgTag;
      };
      var p = {
        glog: function(n) {
          if (n < 1) throw new Error("glog(" + n + ")");
          return p.LOG_TABLE[n];
        },
        gexp: function(n) {
          while (n < 0) n += 255;
          while (n >= 256) n -= 255;
          return p.EXP_TABLE[n];
        },
        EXP_TABLE: new Array(256),
        LOG_TABLE: new Array(256)
      };
      for (var i2 = 0; i2 < 8; i2++) p.EXP_TABLE[i2] = 1 << i2;
      for (var i2 = 8; i2 < 256; i2++) p.EXP_TABLE[i2] = p.EXP_TABLE[i2 - 4] ^ p.EXP_TABLE[i2 - 5] ^ p.EXP_TABLE[i2 - 6] ^ p.EXP_TABLE[i2 - 8];
      for (var i2 = 0; i2 < 255; i2++) p.LOG_TABLE[p.EXP_TABLE[i2]] = i2;
      function r(typeNumber, errorCorrectionLevel) {
        var _typeNumber = typeNumber;
        var _errorCorrectionLevel = f[errorCorrectionLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataList = [];
        var makeImpl = function(test, maskPattern) {
          _moduleCount = _typeNumber * 4 + 17;
          _modules = (function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row++) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col++) {
                modules[row][col] = null;
              }
            }
            return modules;
          })(_moduleCount);
          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);
          if (_typeNumber >= 7) {
            setupTypeNumber(test);
          }
          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
          }
          mapData(_dataCache, maskPattern);
        };
        var setupPositionProbePattern = function(row, col) {
          for (var r3 = -1; r3 <= 7; r3++) {
            if (row + r3 <= -1 || _moduleCount <= row + r3) continue;
            for (var c3 = -1; c3 <= 7; c3++) {
              if (col + c3 <= -1 || _moduleCount <= col + c3) continue;
              _modules[row + r3][col + c3] = (0 <= r3 && r3 <= 6 && (c3 == 0 || c3 == 6)) || (0 <= c3 && c3 <= 6 && (r3 == 0 || r3 == 6)) || (2 <= r3 && r3 <= 4 && 2 <= c3 && c3 <= 4);
            }
          }
        };
        var setupTimingPattern = function() {
          for (var r3 = 8; r3 < _moduleCount - 8; r3++) {
            if (_modules[r3][6] == null) {
              _modules[r3][6] = (r3 % 2 == 0);
            }
          }
          for (var c3 = 8; c3 < _moduleCount - 8; c3++) {
            if (_modules[6][c3] == null) {
              _modules[6][c3] = (c3 % 2 == 0);
            }
          }
        };
        var setupPositionAdjustPattern = function() {
          var pos = y.getPatternPosition(_typeNumber);
          for (var i3 = 0; i3 < pos.length; i3++) {
            for (var j = 0; j < pos.length; j++) {
              var row = pos[i3];
              var col = pos[j];
              if (_modules[row][col] != null) continue;
              for (var r3 = -2; r3 <= 2; r3++) {
                for (var c3 = -2; c3 <= 2; c3++) {
                  _modules[row + r3][col + c3] = (r3 == -2 || r3 == 2 || c3 == -2 || c3 == 2 || (r3 == 0 && c3 == 0));
                }
              }
            }
          }
        };
        var setupTypeNumber = function(test) {
          var bits = y.getBCHTypeNumber(_typeNumber);
          for (var i3 = 0; i3 < 18; i3++) {
            var mod = (!test && ((bits >> i3) & 1) == 1);
            _modules[Math.floor(i3 / 3)][i3 % 3 + _moduleCount - 8 - 3] = mod;
          }
          for (var i3 = 0; i3 < 18; i3++) {
            var mod = (!test && ((bits >> i3) & 1) == 1);
            _modules[i3 % 3 + _moduleCount - 8 - 3][Math.floor(i3 / 3)] = mod;
          }
        };
        var setupTypeInfo = function(test, maskPattern) {
          var data = (_errorCorrectionLevel << 3) | maskPattern;
          var bits = y.getBCHTypeInfo(data);
          for (var i3 = 0; i3 < 15; i3++) {
            var mod = (!test && ((bits >> i3) & 1) == 1);
            if (i3 < 6) {
              _modules[i3][8] = mod;
            } else if (i3 < 8) {
              _modules[i3 + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i3][8] = mod;
            }
          }
          for (var i3 = 0; i3 < 15; i3++) {
            var mod = (!test && ((bits >> i3) & 1) == 1);
            if (i3 < 8) {
              _modules[8][_moduleCount - i3 - 1] = mod;
            } else if (i3 < 9) {
              _modules[8][15 - i3 - 1 + 1] = mod;
            } else {
              _modules[8][15 - i3 - 1] = mod;
            }
          }
          _modules[_moduleCount - 8][8] = (!test);
        };
        var mapData = function(data, maskPattern) {
          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 0;
          var byteIndex = 0;
          var maskFunc = y.getMaskFunction(maskPattern);
          for (var col = _moduleCount - 1; col > 0; col -= 2) {
            if (col == 6) col--;
            while (true) {
              for (var c3 = 0; c3 < 2; c3++) {
                if (_modules[row][col - c3] == null) {
                  var dark = false;
                  if (byteIndex < data.length) {
                    dark = ((data[byteIndex] >>> (7 - bitIndex)) & 1) == 1;
                  }
                  var mask = maskFunc(row, col - c3);
                  if (mask) dark = !dark;
                  _modules[row][col - c3] = dark;
                  bitIndex++;
                  if (bitIndex == 8) {
                    byteIndex++;
                    bitIndex = 0;
                  }
                }
              }
              row += inc;
              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };
        var createData = function(typeNumber, errorCorrectionLevel, dataList) {
          var rsBlocks = k.getRSBlocks(typeNumber, errorCorrectionLevel);
          var buffer = m();
          for (var i3 = 0; i3 < dataList.length; i3++) {
            var data = dataList[i3];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), y.getLengthInBits(data.getMode(), typeNumber));
            data.write(buffer);
          }
          // terminate bits
          var totalDataCount = 0;
          for (var i3 = 0; i3 < rsBlocks.length; i3++) {
            totalDataCount += rsBlocks[i3].dataCount;
          }
          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
          }
          // end code
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }
          // padding to byte
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }
          // padding 0xec, 0x11
          while (buffer.getLengthInBits() < totalDataCount * 8) {
            buffer.put(0xec, 8);
            if (buffer.getLengthInBits() >= totalDataCount * 8) break;
            buffer.put(0x11, 8);
          }
          var dataBits = buffer.getBuffer();
          // allocate data for RS blocks
          var dataBytes = new Array(rsBlocks.length);
          var offset = 0;
          for (var r3 = 0; r3 < rsBlocks.length; r3++) {
            var dc = rsBlocks[r3].dataCount;
            var tc = rsBlocks[r3].totalCount;
            dataBytes[r3] = new Array(dc);
            for (var c3 = 0; c3 < dataBytes[r3].length; c3++) {
              dataBytes[r3][c3] = 0xff & dataBits[c3 + offset];
            }
            offset += dc;
            var rsPoly = p.getErrorCorrectPolynomial(tc - dc);
            var rawPoly = B(dataBytes[r3], 0);
            var modPoly = rawPoly.mod(rsPoly);
            var ecCount = rsPoly.getLength() - 1;
            var ecBytes = new Array(ecCount);
            for (var c3 = 0; c3 < ecBytes.length; c3++) {
              var modIndex = c3 + modPoly.getLength() - ecBytes.length;
              ecBytes[c3] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;
            }
            rsBlocks[r3].ecBytes = ecBytes;
          }
          var totalCodeCount = 0;
          for (var i3 = 0; i3 < rsBlocks.length; i3++) {
            totalCodeCount += rsBlocks[i3].totalCount;
          }
          var qrCodeArray = new Array(totalCodeCount);
          var index = 0;
          var maxDcCount = 0;
          var maxEcCount = 0;
          for (var i3 = 0; i3 < rsBlocks.length; i3++) {
            maxDcCount = Math.max(maxDcCount, rsBlocks[i3].dataCount);
            maxEcCount = Math.max(maxEcCount, rsBlocks[i3].ecBytes.length);
          }
          for (var i3 = 0; i3 < maxDcCount; i3++) {
            for (var r3 = 0; r3 < rsBlocks.length; r3++) {
              if (i3 < rsBlocks[r3].dataCount) {
                qrCodeArray[index++] = dataBytes[r3][i3];
              }
            }
          }
          for (var i3 = 0; i3 < maxEcCount; i3++) {
            for (var r3 = 0; r3 < rsBlocks.length; r3++) {
              if (i3 < rsBlocks[r3].ecBytes.length) {
                qrCodeArray[index++] = rsBlocks[r3].ecBytes[i3];
              }
            }
          }
          return qrCodeArray;
        };
        var _dataCache = null;
        var _this = {
          addData: function(text) {
            var newData = L(text);
            _dataList.push(newData);
            _dataCache = null;
          },
          isDark: function(row, col) {
            if (_modules[row][col] === undefined) throw new Error(row + "," + col);
            return _modules[row][col];
          },
          getModuleCount: function() { return _moduleCount; },
          make: function() {
            // Calculate typeNumber if needed
            if (_typeNumber < 1) {
              // automatic typeNumber calculation
              _typeNumber = 1;
              for (; _typeNumber < 40; _typeNumber++) {
                try {
                  makeImpl(true, 0);
                  break;
                } catch (e3) {
                  // increase typeNumber
                }
              }
            }
            makeImpl(false, getBestMaskPattern());
          },
          createTableTag: function(cellSize, margin) {
            cellSize = cellSize || 2;
            margin = (margin === undefined ? cellSize * 2 : margin);
            var qrHtml = '<table style="border-collapse:collapse; margin:' + margin + 'px;">';
            for (var r3 = 0; r3 < _this.getModuleCount(); r3++) {
              qrHtml += '<tr>';
              for (var c3 = 0; c3 < _this.getModuleCount(); c3++) {
                qrHtml += '<td style="width:' + cellSize + 'px; height:' + cellSize + 'px; padding:0; margin:0; background-color:' + (_this.isDark(r3, c3) ? '#000' : '#fff') + ';"></td>';
              }
              qrHtml += '</tr>';
            }
            qrHtml += '</table>';
            return qrHtml;
          },
          createImgTag: function(cellSize, margin) {
            cellSize = cellSize || 2;
            margin = (margin === undefined ? cellSize * 2 : margin);
            var size = _this.getModuleCount() * cellSize + margin * 2;
            return S(size, size, function(x, y) {
              if (margin <= x && x < size - margin && margin <= y && y < size - margin) {
                var ix = Math.floor((x - margin) / cellSize);
                var iy = Math.floor((y - margin) / cellSize);
                return _this.isDark(iy, ix) ? 0 : 1;
              } else {
                return 1;
              }
            }, null);
          }
        };
        var getBestMaskPattern = function() {
          var minLostPoint = 0;
          var pattern = 0;
          for (var i3 = 0; i3 < 8; i3++) {
            makeImpl(true, i3);
            var lostPoint = y.getLostPoint(_this);
            if (i3 == 0 || lostPoint < minLostPoint) {
              minLostPoint = lostPoint;
              pattern = i3;
            }
          }
          return pattern;
        };
        return _this;
      }
      return r;
    }();
    qrcode.stringToBytes = function(s) {
      // UTF-8 encoding
      return (function(s) {
        var bytes = [];
        for (var i = 0; i < s.length; i++) {
          var c = s.charCodeAt(i);
          if (c < 128) {
            bytes.push(c);
          } else if (c < 2048) {
            bytes.push(192 | (c >> 6));
            bytes.push(128 | (63 & c));
          } else if (c < 55296 || c >= 57344) {
            bytes.push(224 | (c >> 12));
            bytes.push(128 | ((c >> 6) & 63));
            bytes.push(128 | (63 & c));
          } else {
            i++;
            c = 65536 + (((c & 1023) << 10) | (s.charCodeAt(i) & 1023));
            bytes.push(240 | (c >> 18));
            bytes.push(128 | ((c >> 12) & 63));
            bytes.push(128 | ((c >> 6) & 63));
            bytes.push(128 | (63 & c));
          }
        }
        return bytes;
      })(s);
    };
  </script>

  <script>
    /* Application Script */
    // Data storage keys
    let currentUser = null;
    let currentSessionId = null;
    let updateInterval = null;
    // Utility: Save users to localStorage
    function saveUsers(users) {
      localStorage.setItem('users', JSON.stringify(users));
    }
    // Utility: Load users from localStorage (or initialize)
    function loadUsers() {
      let data = localStorage.getItem('users');
      return data ? JSON.parse(data) : [];
    }
    // Utility: Save sessions to localStorage
    function saveSessions(sessions) {
      localStorage.setItem('sessions', JSON.stringify(sessions));
    }
    // Utility: Load sessions list
    function loadSessions() {
      let data = localStorage.getItem('sessions');
      return data ? JSON.parse(data) : [];
    }

    // Registration
    document.getElementById('btn-register').onclick = () => {
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('register-section').style.display = 'block';
    };
    document.getElementById('btn-cancel-reg').onclick = () => {
      document.getElementById('register-section').style.display = 'none';
      document.getElementById('login-section').style.display = 'block';
    };
    document.getElementById('btn-do-register').onclick = () => {
      const phone = document.getElementById('reg-phone').value.trim();
      const email = document.getElementById('reg-email').value.trim();
      const pass = document.getElementById('reg-pass').value;
      if (!phone || !email || !pass) {
        alert("Vui lòng điền đầy đủ thông tin đăng ký!");
        return;
      }
      let users = loadUsers();
      // check unique by phone or email
      if (users.some(u => u.phone === phone || u.email === email)) {
        alert("Số điện thoại hoặc email đã được đăng ký!");
        return;
      }
      // create user object
      let newUser = {
        id: Date.now(), // simple unique id
        phone: phone,
        email: email,
        password: pass,
        expiry: null, // default no expiry (or set initial trial period if needed)
        twoFA: []
      };
      users.push(newUser);
      saveUsers(users);
      alert("Đăng ký thành công! Vui lòng đăng nhập.");
      // Switch back to login
      document.getElementById('register-section').style.display = 'none';
      document.getElementById('login-section').style.display = 'block';
      // Clear reg fields
      document.getElementById('reg-phone').value = '';
      document.getElementById('reg-email').value = '';
      document.getElementById('reg-pass').value = '';
    };

    // Login
    document.getElementById('btn-login').onclick = () => {
      const userInput = document.getElementById('login-user').value.trim();
      const passInput = document.getElementById('login-pass').value;
      if (!userInput || !passInput) {
        alert("Vui lòng nhập tài khoản và mật khẩu!");
        return;
      }
      let users = loadUsers();
      // find user by email or phone
      let user = users.find(u => (u.email === userInput || u.phone === userInput) && u.password === passInput);
      if (!user) {
        alert("Thông tin đăng nhập không đúng!");
        return;
      }
      // Successful login
      currentUser = user;
      // Update UI
      document.getElementById('current-user').innerText = user.email || user.phone;
      document.getElementById('login-section').style.display = 'none';
      document.getElementById('main-section').style.display = 'block';
      // Default to link section visible
      document.getElementById('link-section').style.display = 'block';
      document.getElementById('totp-section').style.display = 'none';
      document.getElementById('tab-link').classList.add('active');
      document.getElementById('tab-totp').classList.remove('active');
      // Load remembered UID/CODE if any for this user
      let savedUID = localStorage.getItem(`uid_${user.id}`);
      let savedCode = localStorage.getItem(`code_${user.id}`);
      if (savedUID) document.getElementById('uid-input').value = savedUID;
      if (savedCode) document.getElementById('code-input').value = savedCode;
      document.getElementById('remember-uidcode').checked = !!(savedUID || savedCode);
      // Load 2FA keys and render list
      renderTotpList();
      // Set up session
      currentSessionId = Date.now().toString(36) + Math.random().toString(36).substr(2);
      let sessions = loadSessions();
      // Remove any existing session for this user on this device (if any, though unlikely)
      // Actually, allow multiple from same device - not an issue, but we'll maintain one per localStorage context anyway.
      sessions.push({
        id: currentSessionId,
        userId: user.id,
        userAgent: navigator.userAgent,
        loginTime: Date.now()
      });
      saveSessions(sessions);
      // Start TOTP auto-update if user has keys
      if (user.twoFA && user.twoFA.length > 0) {
        startTotpInterval();
      }
    };

    // Logout
    document.getElementById('btn-logout').onclick = performLogout;
    function performLogout() {
      // Remove session
      let sessions = loadSessions();
      sessions = sessions.filter(s => s.id !== currentSessionId);
      saveSessions(sessions);
      // Stop TOTP updates
      if (updateInterval) clearInterval(updateInterval);
      currentUser = null;
      currentSessionId = null;
      // Hide main, show login
      document.getElementById('main-section').style.display = 'none';
      document.getElementById('login-section').style.display = 'block';
      // Clear login fields
      document.getElementById('login-user').value = '';
      document.getElementById('login-pass').value = '';
    }

    // Tab switching
    document.getElementById('tab-link').onclick = () => {
      document.getElementById('link-section').style.display = 'block';
      document.getElementById('totp-section').style.display = 'none';
      document.getElementById('tab-link').classList.add('active');
      document.getElementById('tab-totp').classList.remove('active');
    };
    document.getElementById('tab-totp').onclick = () => {
      document.getElementById('link-section').style.display = 'none';
      document.getElementById('totp-section').style.display = 'block';
      document.getElementById('tab-link').classList.remove('active');
      document.getElementById('tab-totp').classList.add('active');
    };

    // Generate password reset links
    document.getElementById('btn-gen-link').onclick = () => {
      const uid = document.getElementById('uid-input').value.trim();
      const code = document.getElementById('code-input').value.trim();
      if (!uid || !code) {
        alert("Vui lòng nhập UID và CODE.");
        return;
      }
      // Remember UID/CODE if checked
      if (document.getElementById('remember-uidcode').checked) {
        localStorage.setItem(`uid_${currentUser.id}`, uid);
        localStorage.setItem(`code_${currentUser.id}`, code);
      } else {
        localStorage.removeItem(`uid_${currentUser.id}`);
        localStorage.removeItem(`code_${currentUser.id}`);
      }
      // Define link patterns for ver1, ver2, ver3
      const baseURL = "https://myapp.com"; 
      const links = [
        `${baseURL}/changepass/v1/${uid}/${code}`,
        `${baseURL}/changepass/v2/${uid}/${code}`,
        `${baseURL}/changepass/v3/${uid}/${code}`
      ];
      const resultsDiv = document.getElementById('link-results');
      resultsDiv.innerHTML = "";
      // Generate each link entry with QR
      links.forEach((link, index) => {
        const entryDiv = document.createElement('div');
        entryDiv.className = 'link-entry';
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'link-actions';
        const linkInput = document.createElement('input');
        linkInput.type = "text";
        linkInput.value = link;
        linkInput.readOnly = true;
        const openBtn = document.createElement('button');
        openBtn.textContent = "Mở";
        openBtn.onclick = () => { window.open(link, '_blank'); };
        const copyBtn = document.createElement('button');
        copyBtn.textContent = "Copy";
        copyBtn.onclick = () => {
          linkInput.select();
          document.execCommand("copy");
          alert("Đã sao chép link vào clipboard.");
        };
        actionsDiv.appendChild(linkInput);
        actionsDiv.appendChild(openBtn);
        actionsDiv.appendChild(copyBtn);
        entryDiv.appendChild(actionsDiv);
        // Create QR code image for the link
        try {
          const qrObj = generateQRCodeObj(link, 'H');
          const qrImgTag = qrObj.createImgTag(4);
          const qrDiv = document.createElement('div');
          qrDiv.className = 'qr-container';
          qrDiv.innerHTML = qrImgTag;
          entryDiv.appendChild(qrDiv);
        } catch (e) {
          console.error("QR creation failed:", e);
        }
        resultsDiv.appendChild(entryDiv);
      });
      document.getElementById('link-message').innerText = "Đã tạo link và QR code.";
    };

    // Toggle remember UID/CODE label clicking
    document.querySelector('label[for="remember-uidcode"]').onclick = () => {
      const cb = document.getElementById('remember-uidcode');
      cb.checked = !cb.checked;
    };

    // 2FA (TOTP) management
    let editingIndex = null;
    document.getElementById('btn-add-totp').onclick = () => {
      const name = document.getElementById('totp-name').value.trim();
      const secret = document.getElementById('totp-secret').value.trim();
      if (!name || !secret) {
        alert("Vui lòng nhập tên và khóa bí mật.");
        return;
      }
      // Validate base32 format (roughly)
      if (!/^[A-Z2-7]+=*$/.test(secret.replace(/\s+/g,''))) {
        alert("Secret phải ở định dạng Base32 (chỉ gồm A-Z và 2-7).");
        return;
      }
      if (editingIndex === null) {
        // Add new key
        currentUser.twoFA.push({ name: name, secret: secret });
      } else {
        // Update existing key
        currentUser.twoFA[editingIndex].name = name;
        currentUser.twoFA[editingIndex].secret = secret;
      }
      // Save users
      let users = loadUsers();
      users = users.map(u => u.id === currentUser.id ? currentUser : u);
      saveUsers(users);
      // Reset form fields
      document.getElementById('totp-name').value = '';
      document.getElementById('totp-secret').value = '';
      // If was editing, end edit mode
      if (editingIndex !== null) {
        editingIndex = null;
        document.getElementById('btn-add-totp').textContent = "Thêm";
        document.getElementById('btn-cancel-edit').style.display = 'none';
      }
      // Re-render list
      renderTotpList();
      // If new key added and interval not yet started, start it
      if (!updateInterval) startTotpInterval();
    };
    document.getElementById('btn-cancel-edit').onclick = () => {
      editingIndex = null;
      document.getElementById('totp-name').value = '';
      document.getElementById('totp-secret').value = '';
      document.getElementById('btn-add-totp').textContent = "Thêm";
      document.getElementById('btn-cancel-edit').style.display = 'none';
    };

    function renderTotpList() {
      const listDiv = document.getElementById('totp-list');
      listDiv.innerHTML = "";
      currentUser.twoFA.forEach((item, index) => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'totp-item';
        // Header with name and code
        const headerDiv = document.createElement('div');
        headerDiv.className = 'totp-header';
        const nameSpan = document.createElement('span');
        nameSpan.className = 'name';
        nameSpan.textContent = item.name;
        const codeSpan = document.createElement('span');
        codeSpan.className = 'code';
        codeSpan.id = `totp-code-${index}`;
        codeSpan.textContent = "------";  // placeholder, will be updated
        headerDiv.appendChild(nameSpan);
        headerDiv.appendChild(codeSpan);
        itemDiv.appendChild(headerDiv);
        // QR code
        const qrDiv = document.createElement('div');
        qrDiv.className = 'totp-qr';
        try {
          const uri = makeOtpAuthUrl(item);
          const qrObj = generateQRCodeObj(uri, 'M');
          const qrImgTag = qrObj.createImgTag(3);
          qrDiv.innerHTML = qrImgTag;
        } catch (e) {
          qrDiv.innerText = "(QR không tạo được)";
          console.error("QR create error:", e);
        }
        itemDiv.appendChild(qrDiv);
        // Action buttons (Edit, Delete)
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'totp-actions';
        const editBtn = document.createElement('button');
        editBtn.textContent = "Sửa";
        editBtn.onclick = () => {
          // Enter edit mode for this key
          editingIndex = index;
          document.getElementById('totp-name').value = item.name;
          document.getElementById('totp-secret').value = item.secret;
          document.getElementById('btn-add-totp').textContent = "Cập nhật";
          document.getElementById('btn-cancel-edit').style.display = 'inline-block';
          // Scroll to form
          document.getElementById('totp-name').scrollIntoView();
        };
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = "Xóa";
        deleteBtn.onclick = () => {
          if (!confirm(`Xóa 2FA "${item.name}"?`)) return;
          currentUser.twoFA.splice(index, 1);
          let users = loadUsers();
          users = users.map(u => u.id === currentUser.id ? currentUser : u);
          saveUsers(users);
          renderTotpList();
        };
        actionsDiv.appendChild(editBtn);
        actionsDiv.appendChild(deleteBtn);
        itemDiv.appendChild(actionsDiv);
        listDiv.appendChild(itemDiv);
      });
    }

    // Generate OTPAuth URI for a secret
    function makeOtpAuthUrl(item) {
      const name = item.name;
      const secret = item.secret.replace(/\s+/g, '');
      let label = encodeURIComponent(name);
      let issuer = "";
      if (name.indexOf(":") !== -1) {
        const parts = name.split(":");
        issuer = encodeURIComponent(parts[0]);
      } else {
        issuer = encodeURIComponent(name);
      }
      let uri = `otpauth://totp/${label}?secret=${secret}`;
      if (issuer) uri += `&issuer=${issuer}`;
      return uri;
    }

    // QR code generation helper using qrcode library
    function generateQRCodeObj(text, level) {
      // level: 'L','M','Q','H'
      // Determine smallest typeNumber that fits
      for (let t = 1; t <= 40; t++) {
        try {
          let qr = qrcode(t, level);
          qr.addData(text);
          qr.make();
          return qr;
        } catch (e) {
          if (e.message && e.message.indexOf("code length overflow") >= 0) {
            continue;
          } else {
            throw e;
          }
        }
      }
      // If none fit, use highest
      let qr = qrcode(40, level);
      qr.addData(text);
      qr.make();
      return qr;
    }

    // TOTP generation using Web Crypto (HMAC-SHA1)
    async function generateTOTP(secret) {
      // Base32 decode secret to ArrayBuffer
      const base32chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
      let cleanSecret = secret.replace(/\s+/g, '').toUpperCase();
      // Pad with '=' to multiple of 8 if needed
      if (cleanSecret.length % 8 !== 0) {
        cleanSecret += "========".substring(0, 8 - (cleanSecret.length % 8));
      }
      let bytes = [];
      for (let i = 0; i < cleanSecret.length; i += 8) {
        let chunk = cleanSecret.substring(i, i+8);
        let bits = 0;
        let validBits = 0;
        for (let j = 0; j < 8; j++) {
          if (chunk[j] !== '=') {
            bits = (bits << 5) | base32chars.indexOf(chunk[j]);
            validBits += 5;
          }
        }
        // pad bits to next byte boundary
        while (validBits >= 8) {
          validBits -= 8;
          bytes.push((bits >> validBits) & 0xFF);
        }
      }
      const keyBytes = new Uint8Array(bytes);
      // Counter as 8-byte array (big-endian)
      const epoch = Math.floor(Date.now() / 1000);
      const time = Math.floor(epoch / 30);
      const counterBuf = new ArrayBuffer(8);
      const counterView = new DataView(counterBuf);
      counterView.setUint32(4, time, false); // set lower 4 bytes (high bytes default 0)
      // HMAC-SHA1 using Web Crypto
      const cryptoKey = await crypto.subtle.importKey("raw", keyBytes, { name: "HMAC", hash: { name: "SHA-1" } }, false, ["sign"]);
      const signature = await crypto.subtle.sign("HMAC", cryptoKey, counterBuf);
      const hash = new Uint8Array(signature);
      const offset = hash[hash.length - 1] & 0x0f;
      const binary = ((hash[offset] & 0x7f) << 24) | ((hash[offset+1] & 0xff) << 16) | ((hash[offset+2] & 0xff) << 8) | (hash[offset+3] & 0xff);
      const otp = binary % 1000000;
      return otp.toString().padStart(6, '0');
    }

    function startTotpInterval() {
      if (updateInterval) clearInterval(updateInterval);
      // Initial update immediately
      updateAllTotpCodes();
      // Update codes every 1 second, recalc on 30-second boundary
      updateInterval = setInterval(updateAllTotpCodes, 1000);
    }
    async function updateAllTotpCodes() {
      const now = new Date();
      const sec = now.getUTCSeconds();
      if (sec === 0 || sec === 30) {
        for (let i = 0; i < currentUser.twoFA.length; i++) {
          try {
            const code = await generateTOTP(currentUser.twoFA[i].secret);
            const codeElem = document.getElementById(`totp-code-${i}`);
            if (codeElem) codeElem.innerText = code;
          } catch (err) {
            console.error("TOTP generation error:", err);
          }
        }
      }
    }

    // Handle being kicked (storage event)
    window.addEventListener('storage', function(e) {
      if (e.key === 'sessions' && currentSessionId) {
        const sessions = loadSessions();
        const stillActive = sessions.some(s => s.id === currentSessionId);
        if (!stillActive) {
          alert("Phiên đăng nhập của bạn đã bị đăng xuất do đăng nhập ở nơi khác.");
          performLogout();
        }
      }
    });
  </script>
</body>
</html>
